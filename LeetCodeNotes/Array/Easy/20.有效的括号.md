---
tags: 
  - 简单
  - 完成
  - 数组
flag: green
style: summer
date: '2019-6-6'
---



# 20.有效的括号


## 一、题目

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。
2.  左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

**输入:** "()"
**输出:** true

**示例 2:**

**输入:** "()[]{}"
**输出:** true

**示例 3:**

**输入:** "(]"
**输出:** false

**示例 4:**

**输入:** "([)]"
**输出:** false

**示例 5:**

**输入:** "{[]}"
**输出:** true



## 二、解答

### （一）思路



**如果只有一种类型的括号**（便于理解，可以不看）

如果简化问题为只有一种类型的括号问题时候：我们将会遇到的表达式是

`(((((()))))) -- VALID`
`()()()()     -- VALID`
`(((((((()    -- INVALID`
`((()(())))   -- VALID`
上我们试着用一个简单的算法来解决这一问题。

1.我们从表达式的左侧开始，每次只处理一个括号。
2.假设我们遇到一个开括号（即 `(`），表达式是否无效取决于在该表达式的其余部分的某处是否有相匹配的闭括号（即 `)`）。此时，我们只是增加计数器的值保持跟踪现在为止开括号的数目。left += 1
3.如果我们遇到一个闭括号，这可能意味着这样两种情况：

  - 此闭括号没有与与之对应的开括号，在这种情况下，我们的表达式无效。当 left == 0，也就是没有未配对的左括号可用时就是这种情况。
  - 我们有一些未配对的开括号可以与该闭括号配对。当 left > 0，也就是有未配对的左括号可用时就是这种情况。

4.如果我们在 left == 0 时遇到一个闭括号（例如 )），那么当前的表达式无效。否则（即匹配了一个左括号），我们会减少 left 的值，也就是减少了可用的未配对的左括号的数量。
5.继续处理字符串，直到处理完所有括号。
6.如果最后我们仍然有未配对的左括号，这意味着表达式无效。

<img src="20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.resource/%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA.gif" alt="算法演示" style="zoom:50%;" />

如果我们只是尝试对原始问题采用相同的办法，这是根本就行不通的。基于简单计数器的方法能够在上面完美运行是因为所有括号都具有相同的类型。因此，当我们遇到一个闭括号时，我们只需要假设有一个对应匹配的开括号是可用的，即假设 `left > 0`。

但是，在我们的问题中，如果我们遇到 `]`，我们真的不知道是否有相应的 `[ `可用。你可能会问：
为什么不为不同类型的括号分别维护一个单独的计数器？

这可能不起作用，因为括号的相对位置在这里也很重要。例如：`[{]`

如果我们只是在这里维持计数器，那么只要我们遇到闭合方括号，我们就会知道此处有一个可用的未配对的开口方括号。但是，**最近的未配对的开括号是一个花括号，而不是一个方括号**，因此计数方法在这里被打破了。





### 本题方案：使用栈

关于有效括号表达式的一个有趣属性是有效表达式的子表达式也应该是有效表达式。（不是每个子表达式）例如

<img src="20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.resource/20-Valid-Parentheses-Recursive-Property.png" alt="20-Valid-Parentheses-Recursive-Property" style="zoom:50%;" />

此外，如果仔细查看上述结构，颜色标识的单元格将标记开闭的括号对。整个表达式是有效的，而它的子表达式本身也是有效的。这为问题提供了一种递归结构。例如，考虑上图中两个绿色括号内的表达式。开括号位于索引 1，相应闭括号位于索引 6。

如果每当我们在表达式中遇到一对匹配的括号时，我们只是从表达式中删除它，会发生什么？

**让我们看看下面的这个想法，从整体表达式中一次删除一个较小的表达式，因为这是一个有效的表达式，我们最后剩留下一个空字符串。**

![算法演示2](20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.resource/%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA2.gif)


在表示问题的递归结构时，栈数据结构可以派上用场。我们无法真正地从内到外处理这个问题，因为我们对整体结构一无所知。但是，栈可以帮助我们递归地处理这种情况，即从外部到内部。

让我们看看使用栈作为该问题的中间数据结构的算法。

**算法**

* 初始化栈 S。
* 一次处理表达式的每个括号。
* 如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。
* 如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。
* 如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。
我们来看一下该算法的动画演示，然后转到实现部分。

![算法最终实现2](20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.resource/%E7%AE%97%E6%B3%95%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B02.gif)

**程序**

```Java
package array.easy;

import java.util.HashMap;
import java.util.Stack;

/**
 * @Author GJXAIOU
 * @Date 2020/1/20 14:50
 */
public class LeetCode20 {

    // 首先使用 HashMap 保存括号的匹配规则
    private HashMap<Character, Character> map;

    // 在构造函数中生成规则
    public LeetCode20() {
        map = new HashMap<Character, Character>();
        map.put(')', '(');
        map.put('}', '{');
        map.put(']', '[');
    }

    public boolean isValid(String s) {

        Stack<Character> stack = new Stack<Character>();

        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            // 判断该元素是否为三种右边括号之一，如果是说明是右边括号，需要弹出栈顶作为匹配
            if (map.containsKey(c)) {
                // 如果栈不为空则弹出栈顶，否则随便弹出一个值
                char topElement = stack.empty() ? '#' : stack.pop();
                // 栈顶元素（左边括号）是否等于 map 中对应的左边括号
                if (topElement != map.get(c)) {
                    return false;
                }
                // 如果不包含该 key，说明是左边括号，压入栈中
            } else {
                stack.push(c);
            }
        }
        // 最后栈应该是空的
        return stack.isEmpty();
    }
}
```

**复杂度分析**

* 时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。
* 空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如`((((((((((`。



### 方案二：思路同上，时间复杂度较高，空间复杂度O(1)

就是不断的将匹配成功的符号删除，最后因为剩余空，否则就不成功。

```java
class Solution {
    public boolean isValid(String s) {
        while(s.contains("()") || s.contains("[]") || s.contains("{}")){
        	if (s.contains("()")) {
        		s = s.replace("()" , "");
        	}
        	if (s.contains("[]")) {
        		s = s.replace("[]" , "");
        	}
        	if (s.contains("{}")) {
        		s = s.replace("{}" , "");
        	}
        }
        return s.isEmpty();
    }
}

```


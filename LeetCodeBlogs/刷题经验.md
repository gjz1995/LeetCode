---
pin: true
---
# 刷题经验




## **多刷题，且误盲目刷题**

说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。

但是，如果你是小白，也就是说，你连**常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划**这些都没学过，那么，我不建议你**盲目疯狂着去刷题**的。**而是先去找本书先去学习这些必要的知识，然后再去刷题**。

也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些**基础包括：**

1、常见数据结构：链表、树(如二叉树)。（是的，链表和二叉树是重点，图这些可以先放着）

2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。（贪婪、穷举、分治是基础，动态规划有难度，可以先放着）




**总结下：**

提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。

### 挑战自己，跳出舒适区

什么叫舒适区？在刷题的时候，可能有一类题是你比较懂的，你每次一看就有思路，然后半个小时就撸好代码，提交代码，然后通过了，然后，哇，又多刷了一道题，心里很舒服。

但是，记住，前期你可以多刷这种题练手，提升自己的乐趣，但，我还是建议你慢慢跳出舒适区，去做一些自己不擅长的题，并且找段时间一直刷这种题。

所以，建议你，一定要学好跳出自己的舒适区。

### AC不是最终目的，而是要追求完美

如何刷题？如何对待一道算法题？

我觉得，在做题的时候，一定要**追求完美**，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。

算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。

我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用**暴力法**都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。

衡量一道算法题的好坏无非就是**时间复杂度**和**空间复杂度**，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。


我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：

1、在刷题的时候，我们要力求完美。

2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。

3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。


### 再谈数据结构的重要性

前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习**链表**和**树(二叉堆)**，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：

1、链表（如单向链表、双向链表）。

2、树（如二叉树、平衡树、红黑树）。

3、图（如最短路径的几种算法）。

4、队列、栈、矩阵。

对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。

例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。



### 学习一些解题技巧

说实话，有些题在你没看别人的解法前，你好不知道有这么美妙优雅的解法，看了之后，卧槽，居然还可以这样。而我们在刷题的过程中，就要不断累积这些技巧，当你累计多了，你就会形成一种 神经反应，一下子就想到了某种方法。解题技巧很多，例如数组下标法、位图法、双指针等等，我自己也分享过一篇总结一些算法技巧的文章。给你举个例子吧，有时候有些技巧真让你大喊“卧槽”。

### 1、找出没有重复的数

> 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。

这道题可能很多人会用一个哈希表来存储，每次存储的时候，记录 某个数出现的次数，最后再遍历哈希表，看看哪个数只出现了一次。这种方法的时间复杂度为 O(n)，空间复杂度也为 O(n)了。

然而我想告诉你的是，采用位运算来做，绝对高逼格！

我们刚才说过，两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下，例如这组数据是：1， 2， 3， 4， 5， 1， 2， 3， 4。其中 5 只出现了一次，其他都出现了两次，把他们全部异或一下，结果如下：

由于异或支持交换律和结合律，所以:

1^2^3^4^5^1^2^3^4 = （1^1)^(2^2)^(3^3)^(4^4)^5= 0^0^0^0^5 = 5。

也就是说，那些出现了两次的数异或之后会变成0，那个出现一次的数，和 0 异或之后就等于它本身。就问这个解法牛不牛逼？所以代码如下

```text
int find(int[] arr){
    int tmp = arr[0];
    for(int i = 1;i < arr.length; i++){
        tmp = tmp ^ arr[i];
    }
    return tmp;
}
```

时间复杂度为 O(n)，空间复杂度为 O(1)，而且看起来很牛逼。

### 2、m的n次方

如果让你求解 2 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下：

```text
int pow(int n){
    int tmp = 1;
    for(int i = 1; i <= n; i++) {
        tmp = tmp * m;
    }
    return tmp;
}
```

不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？

我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:

m^1101 = m^0001 * m^0100 * m^1000。

我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：

```text
int pow(int n){
    int sum = 1;
    int tmp = m;
    while(n != 0){
        if(n & 1 == 1){
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }

    return sum;
}
```

时间复杂度近为 O(logn)，而且看起来很牛逼。

### 最最重要：执行力

动手去做，动手去做，动手去做。重要的话说三遍。


## 经验二：

- 必须有基本的数据结构知识：栈、队列、链表、二叉树等等以及基本的算法思想；
- 先使用伪代码写出程序的逻辑，在补全小段的代码- 针对不需要特定算法的题目；
- 判断题目的描述是否满足某个算法的所需条件；
（主要面临的问题：读题太少，不知每一类算法的使用场景）

- 可以先按照Tag练习，通过Tag练习总结每类算法的特点；
  - 例如使用二分法的基本认识：答案要求有界且单调
- 如果一道题做两次仍然不会就放入收藏夹，同时只有在自己不需要参考答案的连续两次AC的情况下才可以移除；
- 每次结题的时间要有所限制；
- 解题不以AC为目标，要注重时间复杂度和空间复杂度；
- 按照tag进行刷题的时候，像数组、字符串、树、链表、数学这些问题可以先刷，其他尽量不按照tag刷，防止形成思维定式；


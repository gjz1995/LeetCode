{"compress":true,"commitItems":[["44071da1-68c0-47d7-901b-cfa0a16d20ba",1561681399538,"",[[1561681349154,["GJX@GJXAIOU",[[1,0,"# 寻找数组中第K大的元素\n\n\n\n"]],[0,0],[16,16]]],[1561681349259,["GJX@GJXAIOU",[[1,17,"\n"]],[16,16],[17,17]]],[1561681366500,["GJX@GJXAIOU",[[1,16,"这算是一道相当经典的算法题了：\n\n在长度为N的乱序数组中寻找第k（n>=k）大的元素。\n\n扩展思考：如何处理数组中的重复元素？比如，对于数组a={1,2,2,2,3,3,3}，第二大的元素应该是3还是2呢？\n\n本文作这种分类：\n\n如果第二大的元素是3，说明在处理第k大的元素时不处理重复的数据，也就是将原数组进行降序排序后，下标为k-1的元素。这种处理方法称之为“不处理重复数据方法”；\n\n如果第二大的元素是2，说明已经忽略重复的数据了，这时候需要首先对a进行去重处理（可以用哈希表），然后再进行讨论。这种处理方法称之为“去除重复数据方法”。\n\n下面的方法都默认为第一种。\n\n（1）最简单直接的方法：先排序再找\n\n最简单直接的想法是首先进行排序。假设元素的数量不大，比如才几千个，那就可以先进行排序，比如用快排或堆排，平均时间复杂度为O(N*logN)，然后取出前k个，于是总时间复杂度为O(NlogN)+O(k)=O(NlogN)。当然这种做法是浪费了不少的时间的，因为题目只要求找出第k大的元素，而不需要数据是有序的。\n\n（2）比较直接的方法：部分元素排序\n\n当k比较小的时候，k趟排序是个比较不错的方法。我们只需要排序最大的k个元素即可，剩下那些元素不需要管。最简单明了的就是在冒泡排序中只进行k趟起泡：\n\n```\n#include<iostream>using namespace std;int findMaxK(int a[], int n, int k) {    //进行k趟起泡即可    if (k == n) k = n - 1;    bool flag;    for (int i = 0; i < k; i++) {        flag = false;        for (int j = 0; j < n - i - 1; j++) {            if (a[j] > a[j + 1]) {                int tmp = a[j];                a[j] = a[j + 1];                a[j + 1] = tmp;                if (!flag) flag = true;            }        }        if (!flag) break;    }    return a[n - k];}int main() {    int A[] = { 5,1,2,2,3,4,3,10};    int n=8,k =5;    int result= findMaxK(A, n, k);    cout << \"第\" << k << \"大的数字为\" << result << endl;    system(\"pause\");    return 0;}\n```\n\n用上述方法，时间复杂度为O(N*k)，适用于k相对于N很小的情况。\n\n（3）快排的分治法\n\n快速排序使用了分治法的策略。它的基本思想是，选择一个基准数（一般称之为枢纽元），通过一趟排序将要排序的数据分割成独立的两部分：在枢纽元左边的所有元素都不比它大，右边所有元素都比它大，此时枢纽元就处在它应该在的正确位置上了。\n\n在本问题中，假设有N个数存储在数组a中。我们从a中随机找出一个元素作为枢纽元，把数组分为两部分。其中左边元素都不比枢纽元大，右边元素都不比枢纽元小。此时枢纽元所在的位置记为mid。\n\n如果右半边（包括a[mid]）的长度恰好为k，说明a[mid]就是需要的第k大元素，直接返回a[mid]。\n\n如果右半边（包括a[mid]）的长度大于k，说明要寻找的第k大元素就在右半边，往右半边寻找。\n\n如果右半边（包括a[mid]）的长度小于k，说明要寻找的第k大元素就在左半边，往左半边寻找。\n\n```\n#include<iostream>#include<ctime>using namespace std;int divide(int a[], int low,int high) {\t//随机选一个元素作为枢纽元素\t//左边都是比枢纽元素小的，右边都是比枢纽元素大的\tsrand((unsigned)time(NULL));\tint idx = (rand() % (high - low + 1)) + low;\tint tmp = a[low];\ta[low] = a[idx];\ta[idx] = tmp;\ttmp = a[low];\twhile (low < high) {\t\twhile (low<high && a[high] >= tmp) high--;\t\tif (low < high) {\t\t\ta[low] = a[high];\t\t\tlow++;\t\t}\t\twhile (low < high && a[low] <= tmp) low++;\t\tif (low < high) {\t\t\ta[high] = a[low];\t\t\thigh--;\t\t}\t}\t//此时low=high，且low就是枢纽元应该在的位置编号，返回low\ta[low] = tmp;\treturn low;}int findKMax(int a[],int low,int high,int k) {\tint mid = divide(a, low, high);\t//包括a[mid]的右半边长度\tint length_of_right = high - mid + 1;\tif (length_of_right == k) return a[mid];\telse if (length_of_right > k) {\t\t//右半边长度比k长，说明第k大的元素还在右半边，因此在右半边找\t\treturn findKMax(a, mid + 1, high, k);\t}\telse {\t\treturn findKMax(a, low, mid - 1, k - length_of_right);\t}}int main() {\tint A[] = { 1,2,2,2,3,3,3 };\tint n=7,k = 3;\tint result= findMaxK(A, 0,n-1, k);\tcout << \"第\" << k << \"大的数字为\" << result << endl;\tsystem(\"pause\");\treturn 0;}\n```\n\n时间复杂度为O(N*logk)。当然，如果每次选择的枢纽元素都是最坏的那个，时间复杂度就会退化为O(N*k)。\n\n（4）借助优先级队列\n\n前面的解法都可以认为是排序算法的变种，需要对原数组进行多次访问。如果原数组特别大（上百万，甚至上亿），以至于无法存放在内存中，前面的方法就不适用了（毕竟访问外存储器的代价太大）。如果k足够小（k个数据足以放入内存），可以借助二叉堆来完成。这种解法在剑指offer中有所提及，先建立一个规模为k的最小化堆，然后每次拿待处理的数组中元素和堆的最小元素（根结点元素值）比较。如果待插入元素大于根结点元素，则在堆中删除根结点，并把待处理的元素入堆。否则可以抛弃这个元素。\n\n下面用STL标准库中的priority_queue来模拟这个过程：\n\n```\n#include<iostream>#include<queue>using namespace std;struct cmp{\tbool operator()(int &a, int &b) const\t{\t\t//因为优先出列判定为!cmp，所以反向定义实现最小值优先\t\treturn a > b;\t}};int findMaxK(int a[], int n, int k) {\tpriority_queue<int,vector<int>,cmp> myqueue;\tfor (int i = 0; i < n; i++) {\t\tif (myqueue.size() < k) {\t\t\tmyqueue.push(a[i]);\t\t}\t\telse {\t\t\t//将最小元素与a[i]比较\t\t\tint min = myqueue.top();\t\t\tif (a[i] > min) {\t\t\t\tmyqueue.pop();\t\t\t}\t\t\tmyqueue.push(a[i]);\t\t}\t}\treturn myqueue.top();}int main() {\tint A[] = { 1,2,2,2,3,3,3 };\tint n=7,k = 7;\tint result= findMaxK(A, n, k);\tcout << \"第\" << k << \"大的数字为\" << result << endl;\tsystem(\"pause\");\treturn 0;}\n```\n\n时间复杂度为O(N*logk)，因为二叉堆的插入和删除操作都是logk的时间复杂度。上述代码是“不处理重复数据方法”。\n\n如果要求去除重复数据，那用平衡二叉搜索树会更合适。STL标准库中提供的红黑树实现的set就可以解决这个问题。\n\n（5）键值索引法\n\n这个方法对原数组a有要求：所有 N 个数都是正整数，且它们的取值范围不太大（假设a的所有元素都位于区间[0,max]）。此时可以申请一个规模为max+1的数组count，将count的全部元素初始化为0。然后利用count记录a中每个元素出现的个数。这样就可以在O(N)时间复杂度下找到a的第k大元素。\n\n```\n#include<iostream>#include<vector>using namespace std;struct cmp{\tbool operator()(int &a, int &b) const\t{\t\t//因为优先出列判定为!cmp，所以反向定义实现最小值优先\t\treturn a > b;\t}};int findMaxK(int a[], int n, int k,int max) {\tvector<int> count(max + 1);\tfor (int i = 0; i < max; i++) {\t\tcount[i] = 0;\t}\tfor (int j = 0; j < n; j++) {\t\tcount[a[j]]++;\t}\tint ind = max;\twhile (k > 0) {\t\tif (count[ind] == 0) ind--;\t\telse {\t\t\tcount[ind]--;\t\t\tk--;\t\t}\t}\treturn ind;}int main() {\tint A[] = { 5,1,2,2,3,4,3,10};\tint n=8,k = 6;\tint result= findMaxK(A, n, k, 10);\tcout << \"第\" << k << \"大的数字为\" << result << endl;\tsystem(\"pause\");\treturn 0;}\n```\n\n你可能会觉得，这种方法实在是好，只需O(N)的时间复杂度。但仔细想想，上面代码实现的键值索引法并不一定是O(N)的时间复杂度。确实，一开始构建count数组时，只需访问原数组a一次即可，时间为O(N)，但count构建结束后，从count中找到第k大的元素却并不是O(N）时间。大家不妨考虑一种情况：如果max比N大得多呢？比如要找a={1,2,3,100,100}的第3大元素，首先构建一个长度为101的数组，得把数组的全部元素置为0，O(max)。然后用count统计a中每个整数出现的次数，O(N)。最后寻找第3大元素，cout的访问次数为接近100次。因此，这个方法实际的时间复杂度为O(max)。\n\n结论：这种方法的时间复杂度为O(max)，当max与N接近时，才能获得较好的性能。若max远大于N，就是个不好的方法。"]],[16,16],[4933,4933]]],[1561681401256,["GJX@GJXAIOU",[[1,304,"**"],[1,321,"**"]],[304,321],[304,325]]],[1561681403696,["GJX@GJXAIOU",[[-1,305,"*"]],[306,306],[305,305]]],[1561681405823,["GJX@GJXAIOU",[[1,305,"*"],[-1,325,""],[-1,655,"    "],[1,659,"    "],[-1,669,"    "],[1,673,"    "],[-1,695,"    "],[1,699,"    "],[-1,709,"    "],[1,713,"    "],[-1,742,"        "],[1,750,"        "],[-1,763,"        "],[1,771,"        "],[-1,808,"            "],[1,820,"            "],[-1,842,"                "],[1,858,"                "],[-1,873,"                "],[1,889,"                "],[-1,905,"                "],[1,921,"                "],[-1,936,"                "],[1,952,"                "],[-1,975,"            }        }        "],[1,1005,"            }        }        "],[-1,1022,"    }    "],[1,1031,"    }    "],[-1,1060,"    "],[1,1064,"    "],[-1,1094,"    "],[1,1098,"    "],[-1,1111,"    "],[1,1115,"    "],[-1,1145,"    "],[1,1149,"    "],[-1,1195,"    "],[1,1199,"    "],[-1,1215,"    "],[1,1219,"    "]],[305,305],[306,306]]],[1561681410083,["GJX@GJXAIOU",[[1,483,"**"],[1,500,"**"]],[483,500],[483,504]]],[1561681437161,["GJX@GJXAIOU",[[1,603,"\n\n\n\n"],[1,623,"\n\n"],[1,660,"\n\n"],[1,674,"\n\n"],[1,700,"\n\n"],[1,714,"\n\n"],[1,747,"\n\n"],[1,768,"\n\n"],[1,813,"\n\n"],[1,847,"\n\n"],[1,878,"\n\n"],[1,910,"\n\n"],[1,941,"\n\n"],[1,980,"\n\n"],[1,993,"\n\n"],[1,1002,"\n\n"],[1,1027,"\n\n"],[1,1032,"\n\n"],[1,1052,"\n\n"],[1,1053,"\n\n\n\n"],[1,1065,"\n\n"],[1,1099,"\n\n"],[1,1116,"\n\n"],[1,1150,"\n\n"],[1,1200,"\n\n"],[1,1220,"\n\n"],[1,1233,"\n\n"]],[585,1234],[1292,1292]]],[1561681439035,["GJX@GJXAIOU",[[-1,606,"\n"]],[606,606],[605,605]]],[1561681439199,["GJX@GJXAIOU",[[-1,605,"\n"]],[605,605],[604,604]]],[1561681443954,["GJX@GJXAIOU",[[-1,1251,"\n"]],[1251,1251],[1250,1250]]],[1561681445040,["GJX@GJXAIOU",[[-1,1199,"\n"]],[1199,1199],[1198,1198]]],[1561681445709,["GJX@GJXAIOU",[[-1,1163,"\n"]],[1163,1163],[1162,1162]]],[1561681446587,["GJX@GJXAIOU",[[-1,1144,"\n"]],[1144,1144],[1143,1143]]],[1561681447353,["GJX@GJXAIOU",[[-1,1108,"\n"]],[1108,1108],[1107,1107]]],[1561681448906,["GJX@GJXAIOU",[[-1,1089,"\n"]],[1089,1089],[1088,1088]]],[1561681449729,["GJX@GJXAIOU",[[-1,1067,"\n"]],[1067,1067],[1066,1066]]],[1561681451831,["GJX@GJXAIOU",[[-1,1033,"\n"]],[1033,1033],[1032,1032]]],[1561681452735,["GJX@GJXAIOU",[[-1,1059,"\n"]],[1059,1059],[1058,1058]]],[1561681453784,["GJX@GJXAIOU",[[-1,1022,"\n"]],[1022,1022],[1021,1021]]],[1561681454648,["GJX@GJXAIOU",[[-1,1007,"\n"]],[1007,1007],[1006,1006]]],[1561681456553,["GJX@GJXAIOU",[[-1,866,"\n"]],[866,866],[865,865]]],[1561681457549,["GJX@GJXAIOU",[[-1,898,"\n"]],[898,898],[897,897]]],[1561681458459,["GJX@GJXAIOU",[[-1,931,"\n"]],[931,931],[930,930]]],[1561681459412,["GJX@GJXAIOU",[[-1,963,"\n"]],[963,963],[962,962]]],[1561681460600,["GJX@GJXAIOU",[[-1,830,"\n"]],[830,830],[829,829]]],[1561681462394,["GJX@GJXAIOU",[[-1,760,"\n"]],[760,760],[759,759]]],[1561681463126,["GJX@GJXAIOU",[[-1,782,"\n"]],[782,782],[781,781]]],[1561681464798,["GJX@GJXAIOU",[[-1,725,"\n"]],[725,725],[724,724]]],[1561681465346,["GJX@GJXAIOU",[[-1,709,"\n"]],[709,709],[708,708]]],[1561681466124,["GJX@GJXAIOU",[[-1,681,"\n"]],[681,681],[680,680]]],[1561681469276,["GJX@GJXAIOU",[[-1,604,"\n"]],[604,604],[603,603]]],[1561681475462,["GJX@GJXAIOU",[[1,1309,"**"],[1,1318,"**"]],[1309,1318],[1309,1322]]],[1561681485200,["GJX@GJXAIOU",[[-1,1684,"#include<iostream>#include<ctime>using namespace std;int divide(int a[], int low,int high) {\t//随机选一个元素作为枢纽元素\t//左边都是比枢纽元素小的，右边都是比枢纽元素大的\tsrand((unsigned)time(NULL));\tint idx = (rand() % (high - low + 1)) + low;\tint tmp = a[low];\ta[low] = a[idx];\ta[idx] = tmp;\ttmp = a[low];\twhile (low < high) {\t\twhile (low<high && a[high] >= tmp) high--;\t\tif (low < high) {\t\t\ta[low] = a[high];\t\t\tlow++;\t\t}\t\twhile (low < high && a[low] <= tmp) low++;\t\tif (low < high) {\t\t\ta[high] = a[low];\t\t\thigh--;\t\t}\t}\t//此时low=high，且low就是枢纽元应该在的位置编号，返回low\ta[low] = tmp;\treturn low;}int findKMax(int a[],int low,int high,int k) {\tint mid = divide(a, low, high);\t//包括a[mid]的右半边长度\tint length_of_right = high - mid + 1;\tif (length_of_right == k) return a[mid];\telse if (length_of_right > k) {\t\t//右半边长度比k长，说明第k大的元素还在右半边，因此在右半边找\t\treturn findKMax(a, mid + 1, high, k);\t}\telse {\t\treturn findKMax(a, low, mid - 1, k - length_of_right);\t}}int main() {\tint A[] = { 1,2,2,2,3,3,3 };\tint n=7,k = 3;\tint result= findMaxK(A, 0,n-1, k);\tcout << \"第\" << k << \"大的数字为\" << result << endl;\tsystem(\"pause\");\treturn 0;}"]],[1684,2746],[1684,1684]]],[1561681494919,["GJX@GJXAIOU",[[1,1684,"#include<iostream>\n\n#include<ctime>\n\n\n\nusing namespace std;\n\n\n\nint divide(int a[], int low,int high) {\n\n\t//随机选一个元素作为枢纽元素\n\n\t//左边都是比枢纽元素小的，右边都是比枢纽元素大的\n\n\tsrand((unsigned)time(NULL));\n\n\tint idx = (rand() % (high - low + 1)) + low;\n\n\tint tmp = a[low];\n\n\ta[low] = a[idx];\n\n\ta[idx] = tmp;\n\n\ttmp = a[low];\n\n\twhile (low < high) {\n\n\t\twhile (low<high && a[high] >= tmp) high--;\n\n\t\tif (low < high) {\n\n\t\t\ta[low] = a[high];\n\n\t\t\tlow++;\n\n\t\t}\n\n\t\twhile (low < high && a[low] <= tmp) low++;\n\n\t\tif (low < high) {\n\n\t\t\ta[high] = a[low];\n\n\t\t\thigh--;\n\n\t\t}\n\n\t}\n\n\t//此时low=high，且low就是枢纽元应该在的位置编号，返回low\n\n\ta[low] = tmp;\n\n\treturn low;\n\n}\n\n\n\nint findKMax(int a[],int low,int high,int k) {\n\n\tint mid = divide(a, low, high);\n\n\t//包括a[mid]的右半边长度\n\n\tint length_of_right = high - mid + 1;\n\n\tif (length_of_right == k) return a[mid];\n\n\telse if (length_of_right > k) {\n\n\t\t//右半边长度比k长，说明第k大的元素还在右半边，因此在右半边找\n\n\t\treturn findKMax(a, mid + 1, high, k);\n\n\t}\n\n\telse {\n\n\t\treturn findKMax(a, low, mid - 1, k - length_of_right);\n\n\t}\n\n}\n\n\n\n\n\nint main() {\n\n\tint A[] = { 1,2,2,2,3,3,3 };\n\n\tint n=7,k = 3;\n\n\tint result= findMaxK(A, 0,n-1, k);\n\n\tcout << \"第\" << k << \"大的数字为\" << result << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n\n}"]],[1684,1684],[2852,2852]]],[1561681496557,["GJX@GJXAIOU",[[-1,1722,"\n"]],[1722,1722],[1721,1721]]],[1561681496688,["GJX@GJXAIOU",[[-1,1721,"\n"]],[1721,1721],[1720,1720]]],[1561681498947,["GJX@GJXAIOU",[[-1,1720,"\n"]],[1720,1720],[1719,1719]]],[1561681500231,["GJX@GJXAIOU",[[-1,1703,"\n"]],[1703,1703],[1702,1702]]],[1561681502423,["GJX@GJXAIOU",[[-1,1742,"\n"]],[1742,1742],[1741,1741]]],[1561681502560,["GJX@GJXAIOU",[[-1,1741,"\n"]],[1741,1741],[1740,1740]]],[1561681504889,["GJX@GJXAIOU",[[-1,1781,"\n"]],[1781,1781],[1781,1781]]],[1561681505994,["GJX@GJXAIOU",[[-1,1798,"\n"]],[1798,1798],[1798,1798]]],[1561681506878,["GJX@GJXAIOU",[[-1,1825,"\n"]],[1825,1825],[1825,1825]]],[1561681507929,["GJX@GJXAIOU",[[-1,1855,"\n"]],[1855,1855],[1855,1855]]],[1561681508706,["GJX@GJXAIOU",[[-1,1901,"\n"]],[1901,1901],[1901,1901]]],[1561681509494,["GJX@GJXAIOU",[[-1,1920,"\n"]],[1920,1920],[1920,1920]]],[1561681510148,["GJX@GJXAIOU",[[-1,1938,"\n"]],[1938,1938],[1938,1938]]],[1561681510661,["GJX@GJXAIOU",[[-1,1953,"\n"]],[1953,1953],[1953,1953]]],[1561681511207,["GJX@GJXAIOU",[[-1,1968,"\n"]],[1968,1968],[1968,1968]]],[1561681514512,["GJX@GJXAIOU",[[1,1968,"\n\t"]],[1968,1968],[1970,1970]]],[1561681516295,["GJX@GJXAIOU",[[-1,1970,"\t"]],[1970,1970],[1969,1969]]],[1561681518367,["GJX@GJXAIOU",[[-1,1991,"\n"]],[1991,1991],[1991,1991]]],[1561681520832,["GJX@GJXAIOU",[[-1,2036,"\n"]],[2036,2036],[2036,2036]]],[1561681522032,["GJX@GJXAIOU",[[-1,2056,"\n"]],[2056,2056],[2056,2056]]],[1561681525610,["GJX@GJXAIOU",[[-1,2077,"\n"]],[2077,2077],[2077,2077]]],[1561681526461,["GJX@GJXAIOU",[[-1,2087,"\n"]],[2087,2087],[2087,2087]]],[1561681527748,["GJX@GJXAIOU",[[-1,2137,"\n"]],[2137,2137],[2137,2137]]],[1561681528862,["GJX@GJXAIOU",[[-1,2157,"\n"]],[2157,2157],[2157,2157]]],[1561681530305,["GJX@GJXAIOU",[[-1,2178,"\n"]],[2178,2178],[2178,2178]]],[1561681531820,["GJX@GJXAIOU",[[-1,2189,"\n"]],[2189,2189],[2189,2189]]],[1561681532786,["GJX@GJXAIOU",[[-1,2193,"\n"]],[2193,2193],[2193,2193]]],[1561681534032,["GJX@GJXAIOU",[[-1,2235,"\n"]],[2235,2235],[2235,2235]]],[1561681534946,["GJX@GJXAIOU",[[-1,2250,"\n"]],[2250,2250],[2250,2250]]],[1561681535713,["GJX@GJXAIOU",[[-1,2263,"\n"]],[2263,2263],[2263,2263]]],[1561681545150,["GJX@GJXAIOU",[[-1,2811,"\n"]],[2811,2811],[2811,2811]]],[1561681545840,["GJX@GJXAIOU",[[-1,2792,"\n"]],[2792,2792],[2792,2792]]],[1561681546514,["GJX@GJXAIOU",[[-1,2743,"\n"]],[2743,2743],[2743,2743]]],[1561681547206,["GJX@GJXAIOU",[[-1,2707,"\t"]],[2707,2707],[2707,2707]]],[1561681549272,["GJX@GJXAIOU",[[1,2707,"\t"]],[2707,2707],[2707,2707]]],[1561681551111,["GJX@GJXAIOU",[[-1,2706,"\n"]],[2706,2706],[2706,2706]]],[1561681552521,["GJX@GJXAIOU",[[-1,2658,"\n"]],[2658,2658],[2658,2658]]],[1561681553319,["GJX@GJXAIOU",[[-1,2688,"\n"]],[2688,2688],[2688,2688]]],[1561681555166,["GJX@GJXAIOU",[[-1,2633,"\n"]],[2633,2633],[2633,2633]]],[1561681555975,["GJX@GJXAIOU",[[-1,2636,"\n"]],[2636,2636],[2636,2636]]],[1561681556783,["GJX@GJXAIOU",[[-1,2575,"\n"]],[2575,2575],[2575,2575]]],[1561681558313,["GJX@GJXAIOU",[[-1,2566,"\n"]],[2566,2566],[2566,2566]]],[1561681559122,["GJX@GJXAIOU",[[-1,2562,"\n"]],[2562,2562],[2562,2562]]],[1561681559781,["GJX@GJXAIOU",[[-1,2521,"\n"]],[2521,2521],[2521,2521]]],[1561681560831,["GJX@GJXAIOU",[[-1,2485,"\n"]],[2485,2485],[2485,2485]]],[1561681562254,["GJX@GJXAIOU",[[-1,2451,"\n"]],[2451,2451],[2451,2451]]],[1561681562853,["GJX@GJXAIOU",[[-1,2408,"\n"]],[2408,2408],[2408,2408]]],[1561681563569,["GJX@GJXAIOU",[[-1,2368,"\n"]],[2368,2368],[2368,2368]]],[1561681564560,["GJX@GJXAIOU",[[-1,2349,"\n"]],[2349,2349],[2349,2349]]],[1561681565939,["GJX@GJXAIOU",[[-1,2315,"\n"]],[2315,2315],[2315,2315]]],[1561681587889,["GJX@GJXAIOU",[[1,3172,"\n\n"],[1,3187,"\n\n\n\n"],[1,3207,"\n\n\n\n"],[1,3217,"\n\n"],[1,3218,"\n\n"],[1,3256,"\n\n"],[1,3258,"\n\n"],[1,3289,"\n\n"],[1,3304,"\n\n"],[1,3306,"\n\n"],[1,3308,"\n\n\n\n"],[1,3345,"\n\n"],[1,3390,"\n\n"],[1,3420,"\n\n"],[1,3447,"\n\n"],[1,3469,"\n\n"],[1,3472,"\n\n"],[1,3480,"\n\n"],[1,3497,"\n\n"],[1,3524,"\n\n"],[1,3544,"\n\n"],[1,3562,"\n\n"],[1,3566,"\n\n"],[1,3588,"\n\n"],[1,3591,"\n\n"],[1,3593,"\n\n"],[1,3615,"\n\n"],[1,3616,"\n\n\n\n"],[1,3628,"\n\n"],[1,3657,"\n\n"],[1,3672,"\n\n"],[1,3703,"\n\n"],[1,3750,"\n\n"],[1,3767,"\n\n"],[1,3777,"\n\n"]],[3154,3778],[3856,3856]]],[1561681589814,["GJX@GJXAIOU",[[-1,3192,"\n"]],[3191,3191],[3190,3190]]],[1561681589962,["GJX@GJXAIOU",[[-1,3191,"\n"]],[3190,3190],[3189,3189]]],[1561681590161,["GJX@GJXAIOU",[[-1,3188,">"]],[3189,3189],[3188,3188]]],[1561681592033,["GJX@GJXAIOU",[[1,3188,">"]],[3188,3188],[3189,3189]]],[1561681594211,["GJX@GJXAIOU",[[-1,3214,"\n"]],[3213,3213],[3213,3213]]],[1561681594820,["GJX@GJXAIOU",[[-1,3213,"\n"]],[3213,3213],[3213,3213]]],[1561681595698,["GJX@GJXAIOU",[[-1,3224,"\n"]],[3224,3224],[3224,3224]]],[1561681596419,["GJX@GJXAIOU",[[-1,3226,"\n"]],[3226,3226],[3226,3226]]],[1561681597185,["GJX@GJXAIOU",[[-1,3265,"\n"]],[3265,3265],[3265,3265]]],[1561681597905,["GJX@GJXAIOU",[[-1,3270,"\t"]],[3270,3270],[3270,3270]]],[1561681600128,["GJX@GJXAIOU",[[1,3270,"  "]],[3270,3270],[3272,3272]]],[1561681601671,["GJX@GJXAIOU",[[-1,3268,"\n"]],[3268,3268],[3268,3268]]],[1561681603657,["GJX@GJXAIOU",[[-1,3318,"\n"]],[3318,3318],[3318,3318]]],[1561681605423,["GJX@GJXAIOU",[[-1,3301,"\n"]],[3301,3301],[3301,3301]]],[1561681607147,["GJX@GJXAIOU",[[-1,3320,"\n"]],[3320,3320],[3320,3320]]],[1561681608202,["GJX@GJXAIOU",[[-1,3364,"\n"]],[3364,3364],[3364,3364]]],[1561681609329,["GJX@GJXAIOU",[[-1,3410,"\n"]],[3410,3410],[3410,3410]]],[1561681610173,["GJX@GJXAIOU",[[-1,3441,"\n"]],[3441,3441],[3441,3441]]],[1561681611318,["GJX@GJXAIOU",[[-1,3469,"\n"]],[3469,3469],[3469,3469]]],[1561681612204,["GJX@GJXAIOU",[[-1,3492,"\n"]],[3492,3492],[3492,3492]]],[1561681613845,["GJX@GJXAIOU",[[-1,3496,"\n"]],[3496,3496],[3496,3496]]],[1561681615360,["GJX@GJXAIOU",[[-1,3505,"\n"]],[3505,3505],[3505,3505]]],[1561681617175,["GJX@GJXAIOU",[[-1,3523,"\n"]],[3523,3523],[3523,3523]]],[1561681618182,["GJX@GJXAIOU",[[-1,3551,"\n"]],[3551,3551],[3551,3551]]],[1561681620104,["GJX@GJXAIOU",[[-1,3572,"\n"]],[3572,3572],[3572,3572]]],[1561681621479,["GJX@GJXAIOU",[[-1,3591,"\n"]],[3591,3591],[3591,3591]]],[1561681624302,["GJX@GJXAIOU",[[-1,3596,"\n"]],[3596,3596],[3596,3596]]],[1561681625351,["GJX@GJXAIOU",[[-1,3619,"\n"]],[3619,3619],[3619,3619]]],[1561681627525,["GJX@GJXAIOU",[[-1,3623,"\n"]],[3623,3623],[3623,3623]]],[1561681628548,["GJX@GJXAIOU",[[-1,3626,"\n"]],[3626,3626],[3626,3626]]],[1561681630505,["GJX@GJXAIOU",[[-1,3668,"\n"]],[3668,3668],[3668,3668]]],[1561681631354,["GJX@GJXAIOU",[[-1,3698,"\n"]],[3698,3698],[3698,3698]]],[1561681632061,["GJX@GJXAIOU",[[-1,3714,"\n"]],[3714,3714],[3714,3714]]],[1561681632813,["GJX@GJXAIOU",[[-1,3746,"\n"]],[3746,3746],[3746,3746]]],[1561681633568,["GJX@GJXAIOU",[[-1,3794,"\n"]],[3794,3794],[3794,3794]]],[1561681634448,["GJX@GJXAIOU",[[-1,3812,"\n"]],[3812,3812],[3812,3812]]],[1561681650536,["GJX@GJXAIOU",[[1,4133,"\n\n"],[1,4149,"\n\n\n\n"],[1,4169,"\n\n\n\n"],[1,4179,"\n\n"],[1,4180,"\n\n"],[1,4218,"\n\n"],[1,4220,"\n\n"],[1,4251,"\n\n"],[1,4266,"\n\n"],[1,4268,"\n\n"],[1,4270,"\n\n\n\n"],[1,4315,"\n\n"],[1,4343,"\n\n"],[1,4375,"\n\n"],[1,4390,"\n\n"],[1,4392,"\n\n"],[1,4422,"\n\n"],[1,4438,"\n\n"],[1,4440,"\n\n"],[1,4455,"\n\n"],[1,4471,"\n\n"],[1,4500,"\n\n"],[1,4508,"\n\n"],[1,4524,"\n\n"],[1,4531,"\n\n"],[1,4534,"\n\n"],[1,4536,"\n\n"],[1,4548,"\n\n"],[1,4549,"\n\n\n\n"],[1,4561,"\n\n"],[1,4592,"\n\n"],[1,4607,"\n\n"],[1,4642,"\n\n"],[1,4689,"\n\n"],[1,4706,"\n\n"],[1,4716,"\n\n"]],[4115,4717],[4797,4797]]],[1561681652353,["GJX@GJXAIOU",[[-1,4154,"\n"]],[4154,4154],[4153,4153]]],[1561681652507,["GJX@GJXAIOU",[[-1,4153,"\n"]],[4153,4153],[4152,4152]]],[1561681652704,["GJX@GJXAIOU",[[-1,4152,"\n"]],[4152,4152],[4151,4151]]],[1561681653864,["GJX@GJXAIOU",[[-1,4134,"\n"]],[4134,4134],[4133,4133]]],[1561681654556,["GJX@GJXAIOU",[[-1,4174,"\n"]],[4173,4173],[4172,4172]]],[1561681654900,["GJX@GJXAIOU",[[-1,4173,"\n"]],[4172,4172],[4171,4171]]],[1561681656392,["GJX@GJXAIOU",[[-1,4172,"\n"]],[4172,4172],[4171,4171]]],[1561681657448,["GJX@GJXAIOU",[[-1,4183,"\n"]],[4183,4183],[4182,4182]]],[1561681659501,["GJX@GJXAIOU",[[-1,4171,"\n"]],[4171,4171],[4171,4171]]],[1561681661198,["GJX@GJXAIOU",[[1,4171,"\n"]],[4171,4171],[4172,4172]]],[1561681662217,["GJX@GJXAIOU",[[1,4172,"\n"]],[4172,4172],[4173,4173]]],[1561681663404,["GJX@GJXAIOU",[[-1,4186,"\n"]],[4186,4186],[4185,4185]]],[1561681664662,["GJX@GJXAIOU",[[-1,4225,"\n"]],[4225,4225],[4224,4224]]],[1561681665528,["GJX@GJXAIOU",[[-1,4228,"\n"]],[4228,4228],[4227,4227]]],[1561681666380,["GJX@GJXAIOU",[[-1,4260,"\n"]],[4260,4260],[4259,4259]]],[1561681667544,["GJX@GJXAIOU",[[-1,4276,"\n"]],[4276,4276],[4275,4275]]],[1561681669027,["GJX@GJXAIOU",[[-1,4332,"\n"]],[4332,4332],[4331,4331]]],[1561681669775,["GJX@GJXAIOU",[[-1,4361,"\n"]],[4361,4361],[4360,4360]]],[1561681670882,["GJX@GJXAIOU",[[-1,4394,"\n"]],[4394,4394],[4393,4393]]],[1561681672000,["GJX@GJXAIOU",[[-1,4410,"\n"]],[4410,4410],[4409,4409]]],[1561681673473,["GJX@GJXAIOU",[[-1,4445,"\n"]],[4445,4445],[4444,4444]]],[1561681674483,["GJX@GJXAIOU",[[-1,4466,"\n"]],[4466,4466],[4465,4465]]],[1561681675298,["GJX@GJXAIOU",[[-1,4462,"\n"]],[4462,4462],[4461,4461]]],[1561681676717,["GJX@GJXAIOU",[[-1,4481,"\n"]],[4481,4481],[4480,4480]]],[1561681677533,["GJX@GJXAIOU",[[-1,4500,"\t"]],[4500,4500],[4499,4499]]],[1561681679914,["GJX@GJXAIOU",[[1,4499,"    "]],[4499,4499],[4503,4503]]],[1561681681807,["GJX@GJXAIOU",[[-1,4498,"\n"]],[4498,4498],[4498,4498]]],[1561681682921,["GJX@GJXAIOU",[[-1,4531,"\n"]],[4531,4531],[4531,4531]]],[1561681685225,["GJX@GJXAIOU",[[-1,4540,"\n"]],[4540,4540],[4540,4540]]],[1561681686313,["GJX@GJXAIOU",[[-1,4557,"\n"]],[4557,4557],[4557,4557]]],[1561681687321,["GJX@GJXAIOU",[[-1,4565,"\n"]],[4565,4565],[4565,4565]]],[1561681688305,["GJX@GJXAIOU",[[-1,4569,"\n"]],[4569,4569],[4569,4569]]],[1561681689210,["GJX@GJXAIOU",[[-1,4572,"\n"]],[4572,4572],[4572,4572]]],[1561681691186,["GJX@GJXAIOU",[[-1,4637,"\n"]],[4637,4637],[4637,4637]]],[1561681692051,["GJX@GJXAIOU",[[-1,4653,"\n"]],[4653,4653],[4653,4653]]],[1561681692847,["GJX@GJXAIOU",[[-1,4689,"\n"]],[4689,4689],[4689,4689]]],[1561681693630,["GJX@GJXAIOU",[[-1,4737,"\n"]],[4737,4737],[4737,4737]]],[1561681694495,["GJX@GJXAIOU",[[-1,4755,"\n"]],[4755,4755],[4755,4755]]]],null,"GJX@GJXAIOU"]]}